/*
 * Copyright (c) 2017-2018, Niklas Hauser
 * Copyright (c) 2020, Erik Henriksson
 *
 * This file is part of the modm project.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
// ----------------------------------------------------------------------------

#pragma once

#include <type_traits>

#include "../device.hpp"
#include "config.hpp"
#include "modm/architecture/interface.hpp"

namespace modm::platform
{

enum class InputType
{
	Floating = 0x0,  ///< floating on input
	PullUp = 0x1,    ///< pull-up on input
	PullDown = 0x2,  ///< pull-down on input
};

enum class PeripheralPin
{
	BitBang,
	Rx,
	Tx,
	ExtInt,
	Dm,
	Dp,
	Wo,
};

template<typename... Tuples>
using tuple_cat_t = decltype(std::tuple_cat(std::declval<Tuples>()...));

template<class Predicate, class Tuple>
struct tuple_filter;

template<class Predicate, class Tuple>
using tuple_filter_t = typename tuple_filter<Predicate, Tuple>::type;

// Recursive case
template<class Predicate, class X, class... Xs>
struct tuple_filter<Predicate, std::tuple<X, Xs...>>
{
	using type =
		std::conditional_t<Predicate::template value<X>,
						   tuple_cat_t<std::tuple<X>, tuple_filter_t<Predicate, std::tuple<Xs...>>>,
						   tuple_filter_t<Predicate, std::tuple<Xs...>>>;
};

// Base case
template<class Predicate>
struct tuple_filter<Predicate, std::tuple<>>
{
	using type = std::tuple<>;
};

template<class P>
struct EqualsPeripheral
{
	template<class Signal>
	static constexpr bool value = std::is_same_v<P, typename Signal::peripheral>;
};

template<class S>
struct EqualsSignal
{
	template<class Signal>
	static constexpr bool value = std::is_same_v<S, typename Signal::signal>;
};

template<class... Signals>
struct OneOfSignals
{
	template<class Signal>
	static constexpr bool value = ((std::is_same_v<typename Signal::signal, Signals>) | ...);
};

%% if target["family"] in ["g"]

template<class... PinConfigs>
struct PinMuxMixin
{
	inline static void set(uint8_t){};
};

template<class PinConfig, class... PinConfigs>
struct PinMuxMixin<PinConfig, PinConfigs...>
{
	inline static void
	set(uint8_t cfg)
	{
		uint8_t bit0 = cfg & 1;
		uint8_t bit1 = (cfg & 2) >> 1;
		if constexpr (PinConfig::port == PortName::A)
		{
			PIOA->PIO_ABCDSR[0] = (PIOA->PIO_ABCDSR[0] & ~(1<<PinConfig::pin)) | (bit0 << PinConfig::pin);
			PIOA->PIO_ABCDSR[1] = (PIOA->PIO_ABCDSR[1] & ~(1<<PinConfig::pin)) | (bit1 << PinConfig::pin);
		} else if constexpr (PinConfig::port == PortName::B)
		{
			PIOB->PIO_ABCDSR[0] = (PIOB->PIO_ABCDSR[0] & ~(1<<PinConfig::pin)) | (bit0 << PinConfig::pin);
			PIOB->PIO_ABCDSR[1] = (PIOB->PIO_ABCDSR[1] & ~(1<<PinConfig::pin)) | (bit1 << PinConfig::pin);
		}
		PinMuxMixin<PinConfigs...>::set(cfg);
	}
};

template<class... PinConfigs>
class GpioSet : protected PinMuxMixin<PinConfigs...>
{
protected:
	using PinMux = PinMuxMixin<PinConfigs...>;

	static constexpr uint32_t
	mask(PortName port)
	{
		return (((PinConfigs::port == port) ? 1u << PinConfigs::pin : 0u) | ...);
	}

	template<PortName port>
	inline static constexpr volatile uint32_t*
	getPortReg(size_t offset)
	{
		if constexpr (port == PortName::A) {
			return (uint32_t*)((uint8_t*)PIOA + offset);
		}
		if constexpr (port == PortName::B) {
			return (uint32_t*)((uint8_t*)PIOB + offset);
		}
	}

	inline static constexpr void
	setPortReg(size_t offset)
	{
		if constexpr (mask(PortName::A) != 0) { *getPortReg<PortName::A>(offset) = mask(PortName::A); }
		if constexpr (mask(PortName::B) != 0) { *getPortReg<PortName::B>(offset) = mask(PortName::B); }
	}

	template<PortName port>
	inline static constexpr uint32_t
	readPortReg(size_t offset)
	{
		if constexpr (port == PortName::A)
		{
			static_assert(mask(PortName::A) != 0,
						  "Trying to read port which is not in the GpioSet!");
			return *getPortReg<PortName::A>(offset) & mask(PortName::A);
		} else if constexpr (port == PortName::B)
		{
			static_assert(mask(PortName::B) != 0,
						  "Trying to read port which is not in the GpioSet!");
			return *getPortReg<PortName::B>(offset) & mask(PortName::B);
		}
	}

public:
	inline static void
	setOutput()
	{
		setPortReg(PIO_OER_OFFSET);
	}

	inline static void
	setOutput(bool status)
	{
		setOutput();
		set(status);
	}

	static void
	setInput()
	{
		setPortReg(PIO_ODR_OFFSET); // Disable output driver
	}

	static void
	setInput(InputType type)
	{
		configure(type);
		setInput();
	}

	static void
	configure(InputType type)
	{
		if(type == InputType::Floating) {
			setPortReg(PIO_PPDDR_OFFSET); // disable pull down
			setPortReg(PIO_PUDR_OFFSET); // disable pull up
		} else if (type == InputType::PullDown) {
			setPortReg(PIO_PPDER_OFFSET); // Enable pull down
			setPortReg(PIO_PUDR_OFFSET); // disable pull up
		} else {
			setPortReg(PIO_PPDDR_OFFSET); // Disable pull down
			setPortReg(PIO_PUER_OFFSET); // Enable pull up
		}
	}

	static void
	setAnalogInput()
	{}

	static void
	set()
	{
		setPortReg(PIO_SODR_OFFSET);
	}

	static void
	set(bool status)
	{
		if (status)
			set();
		else
			reset();
	}

	static void
	reset()
	{
		setPortReg(PIO_CODR_OFFSET);
	}

	static void
	toggle()
	{
		if constexpr (mask(PortName::A) != 0) {
			volatile uint32_t *reg = getPortReg<PortName::A>(PIO_ODSR_OFFSET);
			uint32_t tmp = *reg;
			tmp ^= mask(PortName::A);
			*reg = tmp;
		}
		if constexpr (mask(PortName::B) != 0) {
			volatile uint32_t *reg = getPortReg<PortName::B>(PIO_ODSR_OFFSET);
			uint32_t tmp = *reg;
			tmp ^= mask(PortName::B);
			*reg = tmp;
		}
	}

	static void
	disconnect()
	{
		setInput(InputType::Floating);
	}
};

%% else

template<class... PinConfigs>
struct PinCfgMixin
{
	inline static void set(uint8_t){};
};

template<class PinConfig, class... PinConfigs>
struct PinCfgMixin<PinConfig, PinConfigs...>
{
	inline static void
	set(uint8_t cfg)
	{
		if constexpr (PinConfig::port == PortName::A)
		{
			PORT->Group[0].PINCFG[PinConfig::pin].reg = cfg;
		} else if constexpr (PinConfig::port == PortName::B)
		{
			PORT->Group[1].PINCFG[PinConfig::pin].reg = cfg;
		}
		PinCfgMixin<PinConfigs...>::set(cfg);
	}
};

template<class... PinConfigs>
class GpioSet : protected PinCfgMixin<PinConfigs...>
{
protected:
	using PinCfg = PinCfgMixin<PinConfigs...>;

	static constexpr uint32_t
	mask(PortName port)
	{
		return (((PinConfigs::port == port) ? 1u << PinConfigs::pin : 0u) | ...);
	}

	template<PortName port>
	inline static constexpr volatile uint32_t*
	getPortReg(size_t offset)
	{
		if constexpr (port == PortName::A) {
			return (uint32_t*)(&PORT->Group[0]) + offset / sizeof(uint32_t);
		}
		if constexpr (port == PortName::B) {
			return (uint32_t*)(&PORT->Group[1]) + offset / sizeof(uint32_t);
		}
	}

	inline static constexpr void
	setPortReg(size_t offset)
	{
		if constexpr (mask(PortName::A) != 0) { *getPortReg<PortName::A>(offset) = mask(PortName::A); }
		if constexpr (mask(PortName::B) != 0) { *getPortReg<PortName::B>(offset) = mask(PortName::B); }
	}

	template<PortName port>
	inline static constexpr uint32_t
	readPortReg(size_t offset)
	{
		if constexpr (port == PortName::A)
		{
			static_assert(mask(PortName::A) != 0,
						  "Trying to read port which is not in the GpioSet!");
			return *getPortReg<PortName::A>(offset) & mask(PortName::A);
		} else if constexpr (port == PortName::B)
		{
			static_assert(mask(PortName::B) != 0,
						  "Trying to read port which is not in the GpioSet!");
			return *getPortReg<PortName::B>(offset) & mask(PortName::B);
		}
	}

public:
	inline static void
	setOutput()
	{
		setPortReg(PORT_DIRSET_OFFSET);
	}

	inline static void
	setOutput(bool status)
	{
		setOutput();
		set(status);
	}

	static void
	setInput()
	{
		setPortReg(PORT_DIRCLR_OFFSET);
	}

	static void
	setInput(InputType type)
	{
		configure(type);
		setInput();
	}

	static void
	configure(InputType type)
	{
		set(type == InputType::PullUp);
		PinCfg::set(PORT_PINCFG_INEN | (type != InputType::Floating) << PORT_PINCFG_PULLEN_Pos);
	}

	static void
	setAnalogInput()
	{}

	static void
	set()
	{
		setPortReg(PORT_OUTSET_OFFSET);
	}

	static void
	set(bool status)
	{
		if (status)
			set();
		else
			reset();
	}

	static void
	reset()
	{
		setPortReg(PORT_OUTCLR_OFFSET);
	}

	static void
	toggle()
	{
		setPortReg(PORT_OUTTGL_OFFSET);
	}

	static void
	disconnect()
	{
		setInput(InputType::Floating);
	}
};
%% endif


template<class PinConfig>
class Gpio : public GpioSet<PinConfig>, public ::modm::GpioIO
{
	using Base = GpioSet<PinConfig>;

public:
	// For backwards compability with bitbang API
	using InputType = ::modm::platform::InputType;

	template<PeripheralPin peripheral_pin_v>
	struct As;

	using Rx = As<PeripheralPin::Rx>;
	using Tx = As<PeripheralPin::Tx>;
	using ExtInt = As<PeripheralPin::ExtInt>;
	using Dm = As<PeripheralPin::Dm>;
	using Dp = As<PeripheralPin::Dp>;

	inline static bool
	read()
	{
%% if target["family"] in ["g"]
		return Base::readPortReg<PinConfig::port>(PIO_PDSR_OFFSET);
%% else
		return Base::readPortReg<PinConfig::port>(PORT_IN_OFFSET);
%% endif
	}

	inline static void
	write(bool status)
	{
		Base::set(status);
	}
};

template<class PinConfig>
template<PeripheralPin peripheral_pin_v>
struct Gpio<PinConfig>::As : public Gpio<PinConfig>
{
	static constexpr PeripheralPin peripheral_pin = peripheral_pin_v;
	using Base = Gpio<PinConfig>;

	template<class Signals, class P>
	struct ValidatePeripheral
	{
		using type = tuple_filter_t<EqualsPeripheral<P>, Signals>;
		static_assert(!std::is_same_v<type, std::tuple<>>,
					  "Gpio pin does not connect to this peripheral! (see above)");
	};

	template<class Signals, class... RequiredSignals>
	struct ValidateSignal
	{
		using type = tuple_filter_t<OneOfSignals<RequiredSignals...>, Signals>;
		static_assert(!std::is_same_v<type, std::tuple<>>,
					  "Gpio pin does not connect to any of the required signals! "
					  "(see above)");
	};

	template<class Signals>
	struct GetSingleSignal
	{
		using crash = typename Signals::errorPeripheralInstanceMatchedMoreThanOneSignal;
	};

	template<class Signal>
	struct GetSingleSignal<std::tuple<Signal>>
	{
		using type = Signal;
	};

	template<class peripheral, class... RequiredSignals>
	struct Connector
	{
		using ValidatedPeripheral =
			typename ValidatePeripheral<typename PinConfig::Signals, peripheral>::type;
		using ValidatedSignals =
			typename ValidateSignal<ValidatedPeripheral, RequiredSignals...>::type;
		using PinSignal = typename GetSingleSignal<ValidatedSignals>::type;
		using Signal = typename PinSignal::signal;

		inline static void
		connect()
		{
%% if target["family"] in ["g"]
			Pio* PIOBase;
			if constexpr (PinConfig::port == PortName::A) {
				PIOBase = PIOA;
			} else {
				PIOBase = PIOB;
			}
			PIOBase->PIO_PDR = (1<<PinConfig::pin);
			Base::PinMux::set((uint32_t)PinSignal::function);
%% else
			Base::PinCfg::set(PORT_PINCFG_PMUXEN);
			if constexpr (PinConfig::pin & 1u)
			{
				PORT->Group[uint32_t(PinConfig::port)].PMUX[PinConfig::pin >> 1].bit.PMUXO =
					uint32_t(PinSignal::function);
			} else
			{
				PORT->Group[uint32_t(PinConfig::port)].PMUX[PinConfig::pin >> 1].bit.PMUXE =
					uint32_t(PinSignal::function);
			}
%% endif
		}

	};
};

template<PeripheralPin peripheral, class... Pins>
struct GetPin;

template<PeripheralPin peripheral_pin, class... Pins>
using GetPin_t = typename GetPin<peripheral_pin, Pins...>::type;

template<PeripheralPin peripheral_pin, class Pin, class... Pins>
struct GetPin<peripheral_pin, Pin, Pins...>
{
	using type = typename std::conditional_t<peripheral_pin == Pin::peripheral_pin, Pin,
											 GetPin_t<peripheral_pin, Pins...>>;
};

template<PeripheralPin peripheral_pin>
struct GetPin<peripheral_pin>
{
	using type = void;
};

}  // namespace modm::platform
